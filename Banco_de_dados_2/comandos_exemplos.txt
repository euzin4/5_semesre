para chamar uma função ja criada usa-se: select nomefunc();

------------------------------------------

CREATE or REPLACE FUNCTION somefunc() RETURNS void AS $$
DECLARE
	quantity integer := 30;
BEGIN
	RAISE NOTICE 'Quantidade é %', quantity;
END; $$
LANGUAGE plpgsql;

-------------------------------------------

create function selecionar(p_itemno int)
returns table(name varchar(50), salary float) as $$
begin
	return query select s.name, s.salary from dados as s where s.id = p_itemno;
end;
$$ language plpgsql;

-------------------------------------------

create or replace function incrementa(a int)
returns int as $$
declare 
	temp int;
begin
	temp = a+1;
	return(temp);
end;
$$ language 'plpgsql';

-------------------------------------------
08/03/19
-------------------------------------------
create table dados ( id int ,  name varchar(50),  age int , address varchar(50), salary float );

1- Crie uma função capaz de aplicar um aumento de 10% para todos os funcionários;

create or replace function asal() returns void as $$
begin
	update dados set salary = salary * 1.1;
end;
$$ language 'plpgsql';

2- Crie uma função capaz de receber um valor de aumento e o número do id do usuário que se deseja aumentar o salário

create or replace function auser(id int, aum float) returns boolean as $$
begin
	aum = aum/100;
	update dados set salary = salary + salary * aum where id = id;
	return found;
end;
$$ language 'plpgsql';

-------------------------------------------
14/03/19
-------------------------------------------

1-crie uma trigger para aumentar 10 % ao salário do salário bruto (devido a impostos) antes de adicionar o valor na tabela.

CREATE FUNCTION aumenta() RETURNS trigger AS $$    //tem que retornar como tipo trigger para funcionar
	BEGIN        
		NEW.salary := NEW.salary*1.1;        
		RETURN NEW;  
	END;
$$ LANGUAGE plpgsql;


//depois de criar a função(neste caso 'aumenta()') o trigger deve ser criado
CREATE TRIGGER aumsal BEFORE INSERT OR UPDATE ON emp FOR EACH ROW EXECUTE PROCEDURE aumenta();	
//o BEFORE é usado para executar o trigger antes de modificar os dados na tabela


--
2-Na  tabela  de  EMPREGADO  abaixo,  faça  um  trigger  de  auditoria  que armazene  as  informações  do  empregado,  bem  como,  o  evento (insert, delete ou   update)  que disparou este trigger, o usuário responsável pela alteração e a data do sistema.EMPREGADO( id integer primary key,  nome varchar(50), cpf varchar(15), Num_Departamentointeger,   Salario  DECIMAL(10,2 ), Supervisor    varchar(50));Auditoria(empregado_ID int, cpf CHAR(12), Num_Departamentointeger,    Salario  DECIMAL(10,2 ),  Supervisor    varchar(50) , evento int, usuario varchar, date date);
evento=1 caso insert
evento=2 caso update
evento=3 caso delete

create or replace function evento() returns trigger as $$
	begin
		if (TG_OP='INSERT') then
			insert into auditoria(evento, usuario, date) values(1, current_user, now());
			return NEW;
		elseif (TG_OP='UPDATE') then
			insert into auditoria(evento, usuario, date) values(2, current_user, now());
			return NEW;
		elseif (TG_OP='DELETE') then
			insert into auditoria(evento, usuario, date) values(3, current_user, now());
		end if;
		return NULL;
	end
$$ language plpgsql;


CREATE TRIGGER tr_evento AFTER INSERT OR UPDATE OR DELETE ON empregado FOR EACH ROW EXECUTE PROCEDURE evento();

---------------------
21/03/19
---------------------

-no terminal pode ser usado 'BEGIN;' antes de executar outros comandos e depois 'END;' para garantir que não haja erros nas modificações do BD;
--
-com a tabela cliente(numero int primary key, cpf int, nome varchar(50)), faça:
1)uma transação com "commit" (faça 3 inserts)
TERMINAL1:
begin;
insert into cliente values (1, 123, 'joao');
insert into cliente values (2, 455, 'jose');
insert into cliente values (3, 562, 'maria');
end;

2)uma transação com "rollback" (faça 3 inserts)
TERMINAL1:
begin;
insert into cliente values (4, 123, joao);	<--nome sem aspas(erro)
insert into cliente values (5, 455, 'jose');
insert into cliente values (6, 562, 'maria');
end;

3)uma transação tentando acessar dados de outra transação ainda não "comitados" (abra dois terminais com o postgres)
TERMINAL1:
begin;
insert into cliente values (7, 974, 'josefa');
(não executar o 'end' e ir para o terminal 2)

TERMINAL2:
begin;
update cliente set cpf=681 where numero=7;
end;

4)rode duas transações com a inserção do mesmo valor de PK, o que acontece? (abra dois terminais com o postgres)
TERMINAL1:
begin;
insert into cliente values (8, 234, 'joao');
(não executar o 'end' e ir para o terminal 2)
end;

TERMINAL2:
begin;
insert into cliente values (8, 098, 'tiao');
end;
(executar o 'end' no terminal1)
----------------------------
 22/03/19
 ----------------------------
 
2-Segundo as operações abaixo:
1) <start t>; 
2) <T,A,10>; 
3) <Start U>; 
4) <U,B,20>; 
5) <T,C,30>; 
6) <T,D,40>; 
7) <Commit T>; 
8) <U,E,50>; 
9) <Commit U>
Suponha que uma operação de checkpoint não bloqueante tenha iniciado imediatamente depois da operação abaixo. Quando o CKPT END é escrito?  
A) 2 
'start ckpt T', entre as linhas 2 e 3
'end ckpt T', entre as linhas 7 e 8
B) 3 
'start ckpt U', entre as linhas 4 e 5
'end ckpt U', entre as linhas 9 e 10
C) 6 
???

---

